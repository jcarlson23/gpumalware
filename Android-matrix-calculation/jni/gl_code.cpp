/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// OpenGL ES 2.0 code

#include <jni.h>
#include <android/log.h>

#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define  LOG_TAG    "libgl2jni"
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)


static void printGLString(const char *name, GLenum s) {
    const char *v = (const char *) glGetString(s);
    LOGI("GL %s = %s\n", name, v);
}

static void checkGlError(const char* op) {
    for (GLint error = glGetError(); error; error
            = glGetError()) {
        LOGI("after %s() glError (0x%x)\n", op, error);
    }
}

GLuint gProgram;
GLuint _positionSlot;
GLuint _colorSlot;
GLuint _texSlot;
GLuint _projectionUniform;
GLuint _modelViewUniform;
GLuint _offset;

unsigned char * bytes;
GLuint texture;
GLint sampler;
GLint mask;
GLuint vertexBuffer;
GLuint indexBuffer;
GLuint heapTexture;
unsigned int screenWidth;
unsigned int screenHeight;

typedef struct {
  float position[2];
  float color[4];
  float texcoord[2];
} Vertex;

const Vertex vertices[] = {
  {{-256, -256},{1,1,1,1}, {0,0}},
  {{-256, 256}, {1,1,1,1}, {0,1}},
  {{256, 256},   {1,1,1,1}, {1,1}},
  {{256,-256},  {1,1,1,1}, {1,0}}
};

const GLubyte indices[] = {
  0,1,2,
  2,3,0
};

static const char gVertexShader[] = 
    "attribute vec4 Position;\n"
    "attribute vec4 SourceColor;\n"
    "varying   vec4 DestinationColor;\n"
    "uniform mat4 Projection;\n"
    "uniform mat4 Modelview;\n"
    "attribute vec2 TexCoord;\n"
    "varying vec2 TexCoordOut;\n"
    "void main() {\n"
    "  DestinationColor = SourceColor;\n"
    "  gl_Position = Projection * Modelview * Position;\n"
    "  TexCoordOut = TexCoord;\n"
    "}\n";

static const char gFragmentShader[] = 
    "varying lowp vec4 DestinationColor;\n"
    "varying lowp vec2 TexCoordOut;\n"
    "uniform sampler2D Texture;\n"
    "uniform sampler2D Mask;\n"
    "uniform lowp vec2 offset;\n"
    "void main() {\n"
    "  lowp vec2 transpose = TexCoordOut.ts;\n"
    "  lowp vec2 original  = TexCoordOut.st;\n"
    "  gl_FragColor = texture2D( Texture, original ) * texture2D( Mask, transpose );\n"
    "}\n";

int analyzeFrameBuffer( unsigned char * data, size_t width, size_t height )
{
  int i,j;
  FILE * tmpfile = fopen("/sdcard/tmp/results.txt","w");
  if ( tmpfile == NULL )
    {
      LOGE("Unable to open file");
      return 1;
    }

  for (j=0; j<height; j++)
    {
      for (i=0; i<width; i++)
	{
	  int byteIndex = (width*4*j) + i * 4;
	  fprintf(tmpfile," 0x%02x%02x%02x%02x ",data[byteIndex+0],data[byteIndex+1],data[byteIndex+2],data[byteIndex+3]);
	}
      fprintf(tmpfile,"\n");
    }
  fclose( tmpfile );
  
  return 0;
}

GLuint createTextureFromData( unsigned char * data, size_t len, size_t dimension ) {
  
  unsigned char * pixels = (unsigned char*) malloc( sizeof(unsigned char) * dimension * dimension * 4 );
  unsigned int i = 0;

  // copy data in pixels...
  for (int y = 0; y<dimension; y++) { 
    for (int x = 0; x<dimension; x++) {
      int byteIndex = (dimension*4*y) + x * 4;

      pixels[byteIndex+3] = 0xff;

      // diagonlize...
      if ( x != y ) continue;

      if ( i > len ) {
	memset( &pixels[byteIndex], '0', sizeof(unsigned char) * 3 );
      } else {
	memcpy( &pixels[byteIndex], &data[i], sizeof(unsigned char) * 3 );
	i+=3;
      }

    }
  }

  GLuint texName;
  glGenTextures(1, &texName );
  glBindTexture(GL_TEXTURE_2D, texName);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, dimension, dimension, 
	       0, GL_RGBA, GL_UNSIGNED_BYTE, pixels );
  return texName;
      
}

GLuint loadShader(GLenum shaderType, const char* pSource) {
    GLuint shader = glCreateShader(shaderType);
    if (shader) {
        glShaderSource(shader, 1, &pSource, NULL);
        glCompileShader(shader);
        GLint compiled = 0;
        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
        if (!compiled) {
            GLint infoLen = 0;
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
            if (infoLen) {
                char* buf = (char*) malloc(infoLen);
                if (buf) {
                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
                    LOGE("Could not compile shader %s:\n%s\n",
			 shaderType == GL_VERTEX_SHADER ? "Vertex Shader" : "Frag Shader" , buf);
                    free(buf);
                }
                glDeleteShader(shader);
                shader = 0;
            }
        }
    }
    return shader;
}

GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
    if (!vertexShader) {
        return 0;
    }

    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
    if (!pixelShader) {
        return 0;
    }

    GLuint program = glCreateProgram();
    if (program) {
        glAttachShader(program, vertexShader);
        checkGlError("glAttachShader");
        glAttachShader(program, pixelShader);
        checkGlError("glAttachShader");
        glLinkProgram(program);
        GLint linkStatus = GL_FALSE;
        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
        if (linkStatus != GL_TRUE) {
	  GLchar messages[256];
	  glGetProgramInfoLog(program, sizeof(messages), 0, &messages[0]);
	  LOGE("GL Program: %s",messages);
	  GLint bufLength = 0;
            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
            if (bufLength) {
                char* buf = (char*) malloc(bufLength);
                if (buf) {
                    glGetProgramInfoLog(program, bufLength, NULL, buf);
                    LOGE("Could not link program:\n%s\n", buf);
                    free(buf);
                }
            }
            glDeleteProgram(program);
            program = 0;
        }
    }
    return program;
}

unsigned char * texels;


void setUpVBOs( void )
{
  glGenBuffers(1, &vertexBuffer );
  glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer );
  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

  glGenBuffers(1,&indexBuffer);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
}


bool setupGraphics(int w, int h) {

    screenWidth = w;
    screenHeight = h;
    printGLString("Version", GL_VERSION);
    printGLString("Vendor", GL_VENDOR);
    printGLString("Renderer", GL_RENDERER);
    printGLString("Extensions", GL_EXTENSIONS);

    LOGI("setupGraphics(%d, %d)", w, h);
    gProgram = createProgram(gVertexShader, gFragmentShader);
    
    
    if (!gProgram) {
        LOGE("Could not create program.");
        return false;
    }
    
    /* 
     *  Use the program we created.. 
     */
    glUseProgram(gProgram);
    checkGlError("glUseProgram");

    // now assign slots, etc..
    _positionSlot = glGetAttribLocation( gProgram, "Position" );
    _colorSlot    = glGetAttribLocation( gProgram, "SourceColor" );
    glEnableVertexAttribArray( _positionSlot );
    glEnableVertexAttribArray( _colorSlot );

    _projectionUniform = glGetUniformLocation( gProgram, "Projection" );
    _modelViewUniform  = glGetUniformLocation( gProgram, "Modelview" );
    _offset            = glGetUniformLocation( gProgram, "offset" );

    _texSlot           = glGetAttribLocation( gProgram, "TexCoord" );
    glEnableVertexAttribArray( _texSlot );
    sampler            = glGetUniformLocation( gProgram, "Texture" );
    mask               = glGetUniformLocation( gProgram, "Mask" );
    

    // set up VBOs
    setUpVBOs( );

    glPixelStorei( GL_UNPACK_ALIGNMENT, 1);

    size_t dimension = 512;
    texels = (unsigned char*) calloc ( dimension * dimension * 3, 1 );
    for (int i=0; i<dimension*dimension*3; i+=3) {
      texels[i+1] = 0xff;
    }

    texture = createTextureFromData( texels, dimension*dimension*3, dimension );

    for (int i=0; i<dimension*dimension*3; i+=3) {
      texels[i+1] = 0xff;
    }
    heapTexture = createTextureFromData( texels, dimension*dimension*3, dimension );

    glViewport(0, 0, dimension, dimension);
    checkGlError("glViewport");
    return true;
}



void renderFrame() {
 
    glBlendFunc( GL_ONE, GL_ONE_MINUS_SRC_ALPHA );
    glEnable( GL_BLEND );

    glClearColor(1.0f, 0.0f, 0.0f, 1.0f);
    checkGlError("glClearColor");
    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
    checkGlError("glClear");
    glEnable( GL_DEPTH_TEST );

    float top    = 512.0f;
    float bottom = 0.0f;
    float left   = 0.0f;
    float right  = 512.0f;
    float aspect = 1.0f;
    float projection[16] = {
      2.0/(right-left), 0.0f, 0.0f, 0.0f,
      0.0f, 2.0f/((top-bottom)*aspect), 0.0f, 0.0f,
      0.0f, 0.0f, -2.0f/1000.0f, -3.0f,
      0.0f, 0.0f, 0.0f, 1.0f 
    };

    float modelview[16] = {
      1.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 1.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 1.0f, 0.0f, 
      0.0f, 0.0f, 0.0f, 1.0f
    };

    glUniformMatrix4fv(_projectionUniform, 1, GL_FALSE, projection );
    glUniformMatrix4fv(_modelViewUniform, 1, GL_FALSE, modelview );

    size_t dimension = 512;
    glViewport(0,0,dimension,dimension);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer );

    glVertexAttribPointer(_positionSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(_colorSlot,4,GL_FLOAT,GL_FALSE,sizeof(Vertex),
			  (GLvoid*)(sizeof(float)*2) );
    glVertexAttribPointer(_texSlot,2,GL_FLOAT,GL_FALSE,sizeof(Vertex),
			  (GLvoid*)(sizeof(float)*6) );
    
    // bind the texture...
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D,texture);
    glUniform1i(sampler,0);

    // bind section texture
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D,heapTexture);
    glUniform1i(mask,1);

    float off[2] = {0.0f, 0.0f};
    glUniform2fv(_offset,1,off);

    glDrawElements( GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);
    checkGlError("glDrawElements");
 
    
    bytes = (unsigned char*) malloc( sizeof(unsigned char) * screenWidth * screenHeight * 4);
    glReadPixels( 0, 0, screenWidth, screenHeight, GL_RGBA, GL_UNSIGNED_BYTE, bytes );
    analyzeFrameBuffer( bytes, screenWidth, screenHeight );
    free( bytes );
    
    
}

extern "C" {
    JNIEXPORT void JNICALL Java_com_gototheboard_gl2jni_GL2JNILib_init(JNIEnv * env, jobject obj,  jint width, jint height);
    JNIEXPORT void JNICALL Java_com_gototheboard_gl2jni_GL2JNILib_step(JNIEnv * env, jobject obj);
};

JNIEXPORT void JNICALL Java_com_gototheboard_gl2jni_GL2JNILib_init(JNIEnv * env, jobject obj,  jint width, jint height)
{
    setupGraphics(width, height);
}

JNIEXPORT void JNICALL Java_com_gototheboard_gl2jni_GL2JNILib_step(JNIEnv * env, jobject obj)
{
    renderFrame();
}
