//
//  Matrix.m
//  Demo B
//
//  Created by Jared Carlson on 5/14/12.
//  Copyright (c) 2012 GoToTheBoard. All rights reserved.
//

#import "Matrix.hpp"
#include <string>
#include <sstream>

using namespace std;

void Matrix::ReOrder( Matrix * &a, Matrix * &b )
{
    Matrix *tmp;
    
    // NSLog(@"A -> %@",a->toString());
    // NSLog(@"B -> %@",b->toString());
    
    if ( a > b )
    {
        // we want to swap
        tmp = (Matrix*) malloc( sizeof(Matrix) );
        memmove(tmp, a, sizeof(Matrix));
        memmove(a, b,  sizeof(Matrix));
        memmove(b, tmp, sizeof(Matrix));
        free(tmp);
        
        tmp = a;
        a = b;
        b = tmp;
    }
    
   // NSLog(@"A -> %@",a->toString());
   // NSLog(@"B -> %@",b->toString());
}

Matrix::Matrix(void) {
    
    Matrix::Increment( &leading[0] );
    
    Matrix::Increment( &trailing[0] );
    row_len = col_len = 0;
    vals = 0x0;
    
}

Matrix::Matrix(unsigned int m,
               unsigned int n)
{

    row_len = m;
    col_len = n;
    
    Matrix::Increment( &leading[0] );
    
    Matrix::Increment( &trailing[0] );
    
    vals = (double*) malloc( m * n * sizeof(double) );
    bzero(vals, m*n*sizeof(double));
    
}

Matrix::Matrix( const Matrix& m)
{

    row_len = m.row_len;
    
    col_len = m.col_len;
    
    Matrix::Increment( &leading[0] );
    
    Matrix::Increment( &trailing[0] );
    
    vals = (double*) malloc( row_len * col_len * sizeof(double) );
    memcpy(vals, m.vals, row_len*col_len*sizeof(double));
    
    
}

NSString *Matrix::toString(void)
{
    stringstream ss (stringstream::in|stringstream::out);
    unsigned int i,j;
    for (i=0; i<row_len; i++) {
        for (j=0; j<col_len; j++)
            ss << " " << this->Element(i,j) << " ";
        ss << "\n";
    }
    
    NSString * resultstr = [[NSString alloc] initWithFormat:@"%s",ss.str().c_str()];
    return resultstr;
}

double &Matrix::Element(unsigned int m, unsigned int n)
{
    unsigned int index = m * col_len + n;
    if ( index > row_len*col_len) 
    {
        
    }
    return vals[index];
    
}

Matrix operator+( Matrix& m1, Matrix& m2)
{
    unsigned int i, j, rows = m1.NumberRows(), cols = m2.NumberCols();
    Matrix om( rows, cols );
    
    for (i=0; i<rows; i++) {
        for (j=0; j<cols; j++) {
            om.Element(i, j) = m1.Element(i, j) + m2.Element(i, j);
        }
    }
    
    return om;
}
Matrix operator-( Matrix& m1, Matrix& m2)
{
    unsigned int i, j, rows = m1.NumberRows(), cols = m2.NumberCols();
    Matrix om( rows, cols );
    
    for (i=0; i<rows; i++) {
        for (j=0; j<cols; j++) {
            om.Element(i, j) = m1.Element(i, j) - m2.Element(i, j);
        }
    }
    
    return om;
}

Matrix operator*( Matrix& m1,  Matrix& m2)
{
    unsigned int i, j, k, rows = m1.NumberRows(), cols = m2.NumberCols();
    Matrix om( rows, cols );
    double sum;
    
    for (i=0; i<rows; i++) {
        for (j=0; j<cols; j++) {
            sum = 0.0;
            for (k=0; k<cols; k++) {
                sum += m1.Element(i, k) * m2.Element(k, j);
            }
            om.Element(i, j) = sum;
        }
    }
    
    return om;
}