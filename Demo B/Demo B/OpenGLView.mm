//
//  OpenGLView.m
//  Darpa CFT
//
//  Created by Jared Carlson on 3/5/12.
//  Copyright 2012 GoToTheBoard. All rights reserved.
//

#import "OpenGLView.h"
#import "AppDelegate.h"
#import "ViewController.hpp"

#define GetGLError()									\
{														\
GLenum err = glGetError();							\
while (err != GL_NO_ERROR) {						\
NSLog(@"GLError %s set in File:%s Line:%d\n",	\
GetGLErrorString(err),					\
__FILE__,								\
__LINE__);								\
err = glGetError();								\
}													\
}

static size_t dimension;

static inline const char * GetGLErrorString(GLenum error)
{
	const char *str;
	switch( error )
	{
		case GL_NO_ERROR:
			str = "GL_NO_ERROR";
			break;
		case GL_INVALID_ENUM:
			str = "GL_INVALID_ENUM";
			break;
		case GL_INVALID_VALUE:
			str = "GL_INVALID_VALUE";
			break;
		case GL_INVALID_OPERATION:
			str = "GL_INVALID_OPERATION";
			break;		
#if defined __gl_h_ || defined __gl3_h_
		case GL_OUT_OF_MEMORY:
			str = "GL_OUT_OF_MEMORY";
			break;
		case GL_INVALID_FRAMEBUFFER_OPERATION:
			str = "GL_INVALID_FRAMEBUFFER_OPERATION";
			break;
#endif
#if defined __gl_h_
		case GL_STACK_OVERFLOW:
			str = "GL_STACK_OVERFLOW";
			break;
		case GL_STACK_UNDERFLOW:
			str = "GL_STACK_UNDERFLOW";
			break;
		case GL_TABLE_TOO_LARGE:
			str = "GL_TABLE_TOO_LARGE";
			break;
#endif
		default:
			str = "(ERROR: Unknown Error Enum)";
			break;
	}
	return str;
}

@implementation OpenGLView

@synthesize viewController;

typedef struct {
    float position[2];
    float color[4];
    float texcoord[2];
} Vertex;

const Vertex vertices[] = {
    {{-128, -128},{1,1,1,1}, {0,0}},
    {{-128, 128}, {1,1,1,1}, {0,1}},
    {{128,128},   {1,1,1,1}, {1,1}},
    {{128,-128},  {1,1,1,1}, {1,0}}
};

const GLubyte indices[] = {
    0,1,2,
    2,3,0
};

+ (Class)layerClass {
    return [CAEAGLLayer class];
}

- (void)printGLString:(const char*)name enum:(GLenum)e
{
    const char *v = (const char*) glGetString(e);
    NSLog(@"%s = %s",name,v);
}

- (void)setupLayer {
    _eaglLayer = (CAEAGLLayer*) self.layer;
    _eaglLayer.opaque = YES;
}

- (void)setupContext {   
    EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;
    _context = [[EAGLContext alloc] initWithAPI:api];
    if (!_context) {
        NSLog(@"Failed to initialize OpenGLES 2.0 context");
        exit(1);
    }
    
    if (![EAGLContext setCurrentContext:_context]) {
        NSLog(@"Failed to set current OpenGL context");
        exit(1);
    }
}

- (void)setupRenderBuffer {
    glGenRenderbuffers(1, &_colorRenderBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);        
    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];   
    
    
}

- (void)setupDepthBuffer {
    glGenRenderbuffers(1, &_depthRenderBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBuffer);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, 
                          self.frame.size.width, self.frame.size.height);    
}



- (void) setupFrameBuffer
{
    glGenFramebuffers(1, &frameBuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);   
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderBuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBuffer);
    

}

// this follows from a normal set that we'll want to continuously check our memory...
- (void)setupDisplayLink {
    
    CADisplayLink* displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(render:)];
    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];  
    
    
}

- (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType {
    
    // compile the shader text
    NSString* shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:@"glsl"];
    NSError* error;
    NSString* shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&error];
    if (!shaderString) {
        NSLog(@"Error loading shader: %@", error.localizedDescription);
        exit(1);
    }
    
    // get a handle to the shader
    GLuint shaderHandle = glCreateShader(shaderType);    
    
    // get the source
    const char * shaderStringUTF8 = [shaderString UTF8String];    
    int shaderStringLength = [shaderString length];
    glShaderSource(shaderHandle, 1, &shaderStringUTF8, &shaderStringLength);
    
    // compile it
    glCompileShader(shaderHandle);
    
    // check that we have a succcesful compilation
    GLint compileSuccess;
    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &compileSuccess);
    if (compileSuccess == GL_FALSE) {
        GLchar messages[256];
        glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &messages[0]);
        NSString *messageString = [NSString stringWithUTF8String:messages];
        NSLog(@"%@", messageString);
        exit(1);
    }
    
    return shaderHandle;
    
}

- (void)setupVBOs {
    
    glGenBuffers(1, &vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    glGenBuffers(1, &indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
    
}

- (void)compileShaders {
    
    // get the frag and vertex shader
    GLuint vertexShader = [self compileShader:@"vertex" withType:GL_VERTEX_SHADER];
    GLuint fragmentShader = [self compileShader:@"fragment" withType:GL_FRAGMENT_SHADER];
       
    // create the shader program
    program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);
    
    
    // check the linkage
    GLint linkSuccess;
    glGetProgramiv(program, GL_LINK_STATUS, &linkSuccess);
    if (linkSuccess == GL_FALSE) {
        GLchar messages[256];
        glGetProgramInfoLog(program, sizeof(messages), 0, &messages[0]);
        NSString *messageString = [NSString stringWithUTF8String:messages];
        NSLog(@"%@", messageString);
        exit(1);
    }
    
    // set this to be the program for use
    glUseProgram(program);
    
    // set up comms with shader from our ObjC code
    _positionSlot = glGetAttribLocation(program, "Position");
    _colorSlot = glGetAttribLocation(program, "SourceColor");
   
    glEnableVertexAttribArray(_positionSlot);
    glEnableVertexAttribArray(_colorSlot);
    
    _projectionUniform = glGetUniformLocation(program, "Projection");
    _modelViewUniform = glGetUniformLocation(program, "Modelview");
    _offset = glGetUniformLocation(program, "offset");
    
    _texSlot   = glGetAttribLocation(program, "TexCoord");
    glEnableVertexAttribArray(_texSlot);
    sampler = glGetUniformLocation(program, "Texture");
    mask    = glGetUniformLocation(program, "Mask");
    
    GetGLError();
}

- (NSUInteger) fitPowerOf2:(NSUInteger)length
{
    NSUInteger n = 1;
    while ( n < length )
        n *= 2;
    return n;
}

// sweep through our texture...
- (void) sweep:(float*)offs
{
    float & x = offs[0];
    float & y = offs[1];
    
    if ( y >= 1.0f )
    {
        x = 0.0f;
        y = 0.0f;
        return;
    }
    else if ( x >= 1.0f )
    {
        x = 0.0f;
        y += 1.0f / (float) dimension;
        return;
    }
    else 
    {
        // periodic
        x -= 1.0f / (float) dimension;
        return;
    }

}

// load the external binary to scan
- (BOOL) loadMemoryPayload:(unsigned char*)payload length:(unsigned int)length
{
    NSUInteger pow = [self fitPowerOf2:(4*length /3)] * 2;
    if ( pow > (dimension*dimension) )
    {
        NSLog(@"Paylaod doesn't fit inside prescribed texture dimension");
        return NO;
    }
    
    unsigned char * data  = (unsigned char*) calloc( sizeof(unsigned char) * dimension*dimension*4, 1 );
    NSUInteger index = 0;
    
    for (NSUInteger y = 0; y < dimension; y++ ) {
        for (NSUInteger x = 0; x < dimension; x++) {
            int byteIndex = (dimension*4 * y) + x * 4;
            
            if ( index > length ) goto endloop;
            memcpy(&data[byteIndex], &payload[index], 3);
            data[byteIndex+3] = 0xff;
            index += 3;
        }
    }
    
// finish and allocate the texture
endloop:
    
    // get rid of the the old texture...
    if ( heapTexture ) {
        glDeleteTextures(1, &heapTexture);
    }
    GLuint texName;
    glGenTextures(1, &texName);
    glBindTexture(GL_TEXTURE_2D, texName);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, dimension, dimension, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
    
    heapTexture = texName;
    
    return YES;
}

// load a signature 
- (GLuint) loadSignatureFromFile:(NSString*)file
{
    NSString * pathToFile   = [[NSBundle mainBundle] pathForResource:file ofType:@"bin"];
    NSData * contentsOfFile = [[NSData alloc] initWithContentsOfFile:pathToFile];
    NSUInteger numBytes = [contentsOfFile length];
    
    NSUInteger pow = [self fitPowerOf2:(4 * numBytes / 3 )] * 2;
    
    if ( pow > (dimension*dimension) )
    {
        NSLog(@"File contents doesn't fit inside texture...");
        return 0;
    }
    
    unsigned char * data  = (unsigned char*) calloc( sizeof(unsigned char) * dimension*dimension*4, 1 );
    unsigned char * buffer = (unsigned char*) [contentsOfFile bytes];
    NSUInteger index = 0;
    
    for (NSUInteger y = 0; y < dimension; y++ ) {
        for (NSUInteger x = 0; x < dimension; x++) {
            int byteIndex = (dimension*4 * y) + x * 4;
            
            if ( index > numBytes ) goto endloop;
            memcpy(&data[byteIndex], &buffer[index], 3);
            data[byteIndex+3] = 0xff;
            index += 3;
        }
    }
    
endloop:
    
    GLuint texName;
    glGenTextures(1, &texName);
    glBindTexture(GL_TEXTURE_2D, texName);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, dimension, dimension, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
    
    return texName;
}

// generate off screen texture
- (GLuint) generateOffScreenTexture
{
    // generate the blank texture we'll populate...
    offTexture = [self generateBlankTexture];
    
    glGetError();
    
    GLuint textureFrameBuffer;
    
    glGenFramebuffers(1, &textureFrameBuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, textureFrameBuffer);
    
    glGenRenderbuffers(1, &_texDepthRenderBuffer);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                           GL_TEXTURE_2D, offTexture, 0);
    
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _texDepthRenderBuffer);

    // need to test for completeness of the frame buffer...
    GLuint status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if ( status != GL_FRAMEBUFFER_COMPLETE )
    {
        NSLog(@"Incomplete framebuffer status");
    }
    
    
    // rebind the frame buffer
    glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);
    return textureFrameBuffer;
}

- (GLuint) generateBlankTexture
{
     
    GLuint texName;
    glGenTextures(1, &texName);
    glBindTexture(GL_TEXTURE_2D, texName);
   
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, dimension, dimension, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    
    
    GetGLError();
        
    return texName;
}


- (GLuint)setupTextureFromData:(unsigned  char*)data length:(NSUInteger)length
{
    
    // create a square texture, of the size of the viewport...
    // we'll slide this into the view
    unsigned char * img = (unsigned char*) calloc( dimension * dimension * 3,
                                                   sizeof(GLubyte));

    NSUInteger h = 0;
    
    // loop over the elements, set the data...
    for (NSUInteger y = 0; y < dimension; y++) {
        for (NSUInteger x = 0; x < dimension; x++) {        
            int byteIndex = (dimension*4 * y) + x * 4;
            
            // ignore the alpha, leave our memory as opaque...( this ensures no unwanted background effect )
            memcpy(&img[byteIndex], &data[h], 3 * sizeof(unsigned char) );
            h += 3;
            
            // set the alpha channel to fully opaque..
            img[byteIndex+3] = 0xff;
            
            // if we've gone past the signature length, reset and rewrite it again...
            if ( h > length )
            {
                h = 0;
                break; // break out of inner-for-loop, to restart the row...
            }
        }
    }
    
    // copy our buffer into the img data...
    // memcpy(img, data, length);
    
    GLuint texName;
    glGenTextures(1, &texName);
    glBindTexture(GL_TEXTURE_2D, texName);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, dimension, dimension, 0, GL_RGBA, GL_UNSIGNED_BYTE, img);
    
    free(img);
    return texName;
    
}

- (id)init
{
    self = [super init];
    if (self) {
        
        // set the dimension...
        dimension = 256;
        firstPass = YES;
        
        // [self setBackgroundColor:[UIColor redColor]];
        size_t bufsize = dimension * dimension * 4 * sizeof(GLubyte);
        bytes = (GLubyte*) malloc( bufsize );
        
        [self setupLayer];
        [self setupContext];
        [self setupDepthBuffer];
        [self setupRenderBuffer];
        [self setupFrameBuffer];
        [self compileShaders];
        [self setupVBOs];
        
        glGetError();
        
        offScreenTexture = [self generateOffScreenTexture];
        
        
        glGetError();
        
        GLint value;
        glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,&value);
        NSLog(@"Maximum number of texture units is %d",value);
        // we can have 8 textures for iOS!
        
        GLint texSize;
        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &texSize);
        NSLog(@"Maximum texture size is %d",texSize);
        //  Maximum texture size is 4096
        
        [self printGLString:"Version" enum:GL_VERSION];
        [self printGLString:"Vendor" enum:GL_VENDOR];
        [self printGLString:"Renderer" enum:GL_RENDERER];
        [self printGLString:"Extensions" enum:GL_EXTENSIONS];
        
        glGetError();
        
        [self setupDisplayLink];
        
        
        offset[0] = 0.0  / (float) dimension; // 113 good place when actually testing
        offset[1] = 0.0;
        
        // Get the renderbuffer size.
        GLint width;
        GLint height;
        glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &width);
        glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &height);
        
        // free(texturebuffer);
    }
    
    return self;
}

- (id) initWithCoder:(NSCoder *)aDecoder
{
    
    self = [super initWithCoder:aDecoder];
    if ( self )
    {
        // set the dimension...
        dimension = 256;
        
        
        // [self setBackgroundColor:[UIColor redColor]];
        size_t bufsize = dimension * dimension * 4 * sizeof(GLubyte);
        bytes = (GLubyte*) malloc( bufsize );
        
        [self setupLayer];
        [self setupContext];
        [self setupDepthBuffer];
        [self setupRenderBuffer];
        [self setupFrameBuffer];
        [self compileShaders];
        [self setupVBOs];
        
        glGetError();
        
        offScreenTexture = [self generateOffScreenTexture];
        
        
        glGetError();
        
        GLint value;
        glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,&value);
        NSLog(@"Maximum number of texture units is %d",value);
        // we can have 8 textures for iOS!
        
        GLint texSize;
        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &texSize);
        NSLog(@"Maximum texture size is %d",texSize);
        //  Maximum texture size is 4096
        
        [self printGLString:"Version" enum:GL_VERSION];
        [self printGLString:"Vendor" enum:GL_VENDOR];
        [self printGLString:"Renderer" enum:GL_RENDERER];
        [self printGLString:"Extensions" enum:GL_EXTENSIONS];
        
        glGetError();
        
        [self setupDisplayLink];
        
        

        offset[0] = 0.0  / (float) dimension; // 113 good place when actually testing
        offset[1] = 0.0;
        
        // Get the renderbuffer size.
        GLint width;
        GLint height;
        glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &width);
        glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &height);
        
        // free(texturebuffer);
        
                
    }
    return self;
}


- (void)renderCheck:(CADisplayLink*)displayLink
{
    NSLog(@"checking...");
    
}

- (void)renderToScreen
{
    glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);
    
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);
    
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    glEnable(GL_DEPTH_TEST);
    
    float top = 256.0f;
    float bottom = 0.0f;
    float left = 0.0f;
    float right = 256.0f;
    float aspect = 1.0f; //(float) self.frame.size.width / (float) self.frame.size.height;
    float projection[16] = { 
        2.0/(right-left), 0.0f, 0.0f, 0.0f,
        0.0f, 2.0f/((top-bottom)*aspect), 0.0f, 0.0f,
        0.0f, 0.0f, -2.0f/1000.0f, -3.0f,
        0.0, 0.0, 0.0, 1.0f 
    };
    float modelview[16]  = {
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f, 1.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    };
    
    GetGLError();
    
    
    glUniformMatrix4fv(_projectionUniform, 1, GL_FALSE,
                       projection);
    glUniformMatrix4fv(_modelViewUniform, 1, GL_FALSE,
                       modelview);
    
    GetGLError();
    
    glViewport(0, 0, 256, 256);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    
    GetGLError();
    
    glVertexAttribPointer(_positionSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)(sizeof(float)*2) );
    glVertexAttribPointer(_texSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 
                          (GLvoid*)(sizeof(float)*6) );
    
    GetGLError();
    
    // set up our data to be sampled within the texture
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture);
    glUniform1i(sampler, 0);
    
    GetGLError();
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, heapTexture);
    glUniform1i(mask, 1);

    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);
    
    // capture the data for analysis...
    memset(bytes,'\0',dimension*dimension*4);
    glReadPixels(0, 0, dimension, dimension, GL_RGBA, GL_UNSIGNED_BYTE, bytes);
    // could be an issue with the screen size... looks to me like there's more data
    // than just the screen size...
    [self analyzePixelData:bytes offset:offset];
    
    [_context presentRenderbuffer:GL_RENDERBUFFER];
    
    
}

- (BOOL)renderToTexture
{
    BOOL result = NO;
    unsigned char * texturedata = (unsigned char*) malloc( dimension * dimension * 4 );
    
    // bind our texture to render to...
    glBindFramebuffer(GL_FRAMEBUFFER, offScreenTexture);
    
    // gl calls, as before...
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);
    
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    glEnable(GL_DEPTH_TEST);
    
    float top = 256.0f;
    float bottom = 0.0f;
    float left = 0.0f;
    float right = 256.0f;
    float aspect = 1.0f; //(float) self.frame.size.width / (float) self.frame.size.height;
    float projection[16] = { 
        2.0/(right-left), 0.0f, 0.0f, 0.0f,
        0.0f, 2.0f/((top-bottom)*aspect), 0.0f, 0.0f,
        0.0f, 0.0f, -2.0f/1000.0f, -3.0f,
        0.0, 0.0, 0.0, 1.0f 
    };
    float modelview[16]  = {
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f, 1.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    };
    
    GetGLError();
    
    
    glUniformMatrix4fv(_projectionUniform, 1, GL_FALSE,
                       projection);
    glUniformMatrix4fv(_modelViewUniform, 1, GL_FALSE,
                       modelview);
    
    GetGLError();
    
    glViewport(0, 0, 256, 256);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    
    GetGLError();
    
    glVertexAttribPointer(_positionSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)(sizeof(float)*2) );
    glVertexAttribPointer(_texSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 
                          (GLvoid*)(sizeof(float)*6) );
    
    GetGLError();
    
    
    //
    // set up our data to be sampled within the texture
    //
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, heapTexture);
    glUniform1i(sampler, 0);
    
    GetGLError();

    
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);
    
    // copy from the texture to image...
    glReadPixels(0, 0, dimension, dimension, GL_RGBA, GL_UNSIGNED_BYTE, texturedata );
    
    // analyze the results...
    if ( [self analyzeBuffer:texturedata] )
        result = YES;
    
    // unbind the frame buffer...
    glBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);
    
    free( texturedata );
    
    return result;
}

- (BOOL) analyzeBuffer:(unsigned char*)payload
{
    unsigned int nobjects = 0;
    unsigned char * redbyte = (unsigned char*) malloc(3 * sizeof(unsigned char) );
    redbyte[0] = 0xff;
    redbyte[1] = 0x00;
    redbyte[2] = 0x00;
    int byteIndex;
    
    for (NSUInteger y = 0; y < dimension; y++) {
        for (NSUInteger x = 0; x < dimension; x++) {        
            
            byteIndex = (dimension*4 * y) + x * 4;     
            if ( !memcmp(&payload[byteIndex], redbyte, 3 * sizeof( unsigned char ) ) )
                nobjects++;
        }
    }
    
    
    // first pass allows for assignment
    if ( firstPass ) {
        tracked_objects = nobjects;
        firstPass = NO;
    } else {
        if ( nobjects != tracked_objects )
            return YES;
    }
    
    return NO;
}

- (void)render:(CADisplayLink*)displayLink
{
   
    
    // grab updated memory...
    unsigned char * p = [viewController ptr];
    unsigned int mlength=[viewController memory_length];
    [self loadMemoryPayload:p length:mlength];
    
    if ( [self renderToTexture] )
    {
        [viewController alertAndQuit];
    }
    
    
    
}

// analysis functions
- (void) analyzePixelData:(void*)pixels offset:(float*)offset
{
    uint zeros = 0;
    unsigned char * fournull = (unsigned char*) calloc( 3 * sizeof(unsigned char), 1 );
    
    for (NSUInteger y = 0; y < dimension; y++) {
        for (NSUInteger x = 0; x < dimension; x++) {        
            
            int byteIndex = (dimension*4 * y) + x * 4;            
            if ( byteIndex > 100 ) return; 
            
            // see if we've got a null..
            if ( memcmp( &((unsigned char*)pixels)[byteIndex], fournull, 3) == 0)
            {
                zeros+=3;
                if ( zeros >= _sigThreshold )
                {
                    NSLog(@"Found the sinature match!");
                    // 
                    // [(AppDelegate*)[[UIApplication sharedApplication] delegate] message:@"Found signature match"];
                    NSLog(@"Found this at index %d",byteIndex - zeros);
                }
            }
            // else we force a restart of the count
            else {
                zeros = 0;
            }
        }
    }
    
    // now the point is to find the right matching sequence of zeros...
    
}

- (void) analyzePixelHeap:(void*)pixels
{
    // we look for a pattern in the within the heap...
}

- (void) setSignatureThreshold:(NSString*)sigfile
{
    NSString * pathToFile   = [[NSBundle mainBundle] pathForResource:sigfile ofType:@"bin"];
    NSData * contentsOfFile = [[NSData alloc] initWithContentsOfFile:pathToFile];
    NSUInteger numBytes = [contentsOfFile length];
    _sigThreshold = numBytes - 2;
}

@end
