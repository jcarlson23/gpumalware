#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <Accelerate/Accelerate.h>

typedef struct {
  char **opcodes;
  unsigned int numberOpcodes;
  float * elements;
  unsigned int numberElements;
} matrix;

matrix *read_matrix_from_file( const char * filename );
void print_matrix( FILE * file, matrix * m );
int destroy_matrix( matrix * m );
void populate_vector( float * vector, int nels, char ** opcodes, char * code ); 
void print_vector(float * result, int nels);
void print_result(float * result, int nels, char **opcodes );
char *choose_opcode( float * result, int nels, char **opcodes );

int main( int argc, char * argv[] )
{

  /*
   * BLAS documentation
   * https://developer.apple.com/library/ios/#DOCUMENTATION/Accelerate/Reference/BLAS_Ref/Reference/reference.html
   */

  /*
   * Here's a really good source...
   * http://www.prism.gatech.edu/~ndantam3/cblas-doc/doc/html/cblas_8h.html
   */

  /*
   * doc's for LAPACK functions can be found at:
   * http://www.netlib.org/lapack/lug/node147.html#22228
   */
  int solve_for_instruction = 0;
  char * matrixfile = NULL;
  matrix * m; // = read_matrix_from_file( "matrix.txt" );
  //  print_matrix( stdout, m );
  // destroy_matrix( m );

  
  if ( argc == 3 ) {
    solve_for_instruction = 1;
    matrixfile = argv[2];
  } else if ( argc == 1 ) {
    matrixfile = NULL;
  } else {
    printf("Usage %s [previous opcode] [matrix file]\n",argv[0]);
    exit(1);
  }

  __CLPK_integer info;
  float alpha = 1.0f;
  float beta  = 1.0f;

  if ( solve_for_instruction ) 
  {
    m = read_matrix_from_file( matrixfile );
    
    __CLPK_integer mn = (__CLPK_integer) m->numberOpcodes;
    float * vec, * result;
    vec = (float*) malloc( sizeof(float) * m->numberOpcodes );
    result=(float*)malloc( sizeof(float) * m->numberOpcodes );

    // populate the vector...
    populate_vector( vec, m->numberOpcodes, m->opcodes, argv[1] );
    
    cblas_sgemv( CblasColMajor, CblasNoTrans, mn, mn, alpha, m->elements,
		 mn, vec, 1, beta, result, 1 );
    
    char * chosen_opcode = choose_opcode( result, m->numberOpcodes, m->opcodes );
    printf("%s\n",chosen_opcode);
    // print_vector( result, m->numberOpcodes );

    free( vec );
    free( result );
    destroy_matrix( m );
    return 0;
  }
    
    matrix * a = read_matrix_from_file( "matrix.txt" );
    __CLPK_integer dim = (__CLPK_integer) a->numberOpcodes;
    float * testA      = a->elements;

    __CLPK_integer n = 3;
    
    float A[9] = { 2.0f, 0.0f, 0.0f, // first column
                   0.0f, -1.0f, 0.0f,  // second column
                   0.0f, 0.0f, 2.0f };
    
    __CLPK_integer ipiv[3];
    
    sgetrf_(&n, &n, A, &n, ipiv, &info);
    printf(" dim = %d,  n = %d\n",dim,n);
    if ( info != 0 ) {
        printf("sgetrf failed with error code %d\n",(int)info);
        return 0;
    }
    
    __CLPK_integer inc = 1;

    float c[3] = {1.0f, 1.0f, 1.0f };
    float b[3] = {2.0f, -3.0f, 4.0f };
    
    char transpose = 'N';
    __CLPK_integer nrhs = 1;
    
    sgetrs_(&transpose, &n, &nrhs, A, &n, ipiv, b, &n, &info);
    printf(" n = %d\n",n);    
    if ( info != 0 ) {
        printf("sgetrs failed with error code %d\n",(int)info);
        return 0;
    }

    printf("b = [ %f %f %f ]\n",b[0],b[1],b[2]);
    printf("c = [ %f %f %f ]\n",c[0],c[1],c[2]);
    printf("\n");

    printf(" testA * b \n");
    cblas_sgemv( CblasColMajor, CblasTrans, n, n, alpha, testA, n, b, 1, beta, c, 1);
    printf("x = [ %f %f %f ]\n",c[0],c[1],c[2]);
    
    printf(" b \n");
    printf("x = [ %f %f %f ]\n",b[0],b[1],b[2]);

    printf(" scaling b by 1.5 \n");
    cblas_sscal( n, 1.5f, b, 1 );
    printf("x = [ %f %f %f ]\n",b[0],b[1],b[2]);
    
    printf(" A * b \n");
    cblas_sgemv( CblasColMajor, CblasNoTrans, n, n, alpha, A, n, b, 1, beta, c, 1 );
    printf("x = [ %f %f %f ]\n",c[0],c[1],c[2]);
    destroy_matrix( a );
    return 0;
}


matrix *read_matrix_from_file( const char * filename )
{
  FILE * fhandle = fopen( filename, "r" );
  if ( fhandle == NULL )
    return NULL;

  matrix * pmtrx = (matrix*) malloc( sizeof(matrix) );
  float num;

  // read in the first line, containing the opcodes...
  unsigned int commas = 0, linelength = 0;
  int c;

  while ( (c = fgetc(fhandle)) != EOF ) {
    linelength++;
    if ( c == ',' ) commas++;
    if ( c == '\n') break;
  }

  // rewind the file...
  rewind(fhandle);
  pmtrx->numberOpcodes = commas+1;
  pmtrx->numberElements= pmtrx->numberOpcodes * pmtrx->numberOpcodes;
  pmtrx->opcodes = (char**) malloc( sizeof(char*) * pmtrx->numberOpcodes );
  pmtrx->elements= (float*) malloc( sizeof(float) * pmtrx->numberElements );

  char * cptr, * line = (char*) malloc( sizeof(char) * linelength );
  fgets( line, linelength, fhandle );
  
  // read in our opcdoes...
  cptr = strtok( line, "," );
  c = 0;
  while ( cptr != NULL )
    {
      pmtrx->opcodes[c++] = strdup( cptr );
      cptr = strtok(NULL,",");
    }

  free( line );

  c = 0;
  while ( fscanf(fhandle," %f ",&num) )
    {
      pmtrx->elements[c++] = num;
      if ( c == pmtrx->numberElements )
	break;
    }

  fclose(fhandle);
  // done...
  
  return pmtrx;
  
}

void print_matrix( FILE * file, matrix * m )
{
  int i,j;
  int num = (int) sqrtf( m->numberElements );
  for (i=0; i<m->numberOpcodes; i++)
    fprintf(file," %8s ", m->opcodes[i] );
  fprintf(file,"\n");

  for (i=0; i<num; i++)
    {
      for (j=0; j<num; j++)
	fprintf(file," %8f ",m->elements[i*num+j]);
      fprintf(file,"\n");
    }
}

int destroy_matrix( matrix * m )
{
  int i;
  for (i=0; i<m->numberOpcodes; i++)
    free( m->opcodes[i] );

  free( m->elements );
  free( m->opcodes );

  m->numberOpcodes = 0;
  m->numberElements= 0;

  m = NULL;

  return 0;
}

void populate_vector( float * vector, 
		      int nels, 
		      char ** opcodes, 
		      char * code )
{
  int i;
  for (i=0; i<nels; i++) {
    if ( strncmp(opcodes[i],code,4) == 0 )
      vector[i] = 1.0f;
    else
      vector[i] = 0.0f;
  }
  // end of function
}


void print_vector(float * result, int nels)
{
  int i;
  for (i=0; i<nels; i++)
    printf(" %8f ",result[i]);
}

void print_result(float * result, int nels, char **opcodes )
{
  int i;
  // print out json result, can import into python easily...
  printf("{");
  for ( i=0; i<nels; i++ )
    {
      if ( result[i] > 0.0f )
	printf("'%s':%f,",opcodes[i],result[i]);
    }
  printf("}");
}


char *choose_opcode( float * result, int nels, char **opcodes )
{
  // get a rand num [0,1]
  float num = ( (float) rand() / (float) RAND_MAX );
  float sum = 0.0f;
  int i;
  for (i=0; i<nels; i++) 
    {
      sum += result[i];
      if ( num < sum )
	return opcodes[i];
    }
  return NULL;
}
