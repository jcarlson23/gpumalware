#include <iostream>
#include <algorithm>
#include <fstream>
#include <unistd.h>
#include <getopt.h>
#include "trie.h"
#include "util.h"
#include "controller.h"
#include "matrix.h"


using std::fstream;
using std::cout;
using std::endl;
using std::string;

int main( int argc, char *argv[] )
{

  /*
   * Argument error check
   */
  if ( argc< 2 )
    {
      cout << "Usage: " << argv[0] << " <infile> [additional file or file patterns]" << endl;
      exit(0);
    }

  /*
   * Parse argument
   */
  int option_index, c;
  bool dump_opcode   = false;
  bool combine_files = false;
  bool gen_digraph   = false;
  string outFileName = "temp.txt";
  string treeName    = "";
  bool dump_all      = false;

  static struct option options[] = {
    {"opcodes",0,0,0},
    {"outfile",1,0,0},
    {"combine",0,0,0},
    {"digraph",0,0,0},
    {"all",1,0,0},
    {NULL,0,NULL,0},
  };

  while( (c = getopt_long( argc, argv, "a:cgo:x", options, &option_index) ) != -1 )
    {
      switch ( c ) 
	{
	case 'a':
	  cout << "Dumping all instructions.." << endl;
	  dump_all = true;
	  treeName = optarg;
	  break;
	case 'x':
	  cout << "opcode output..." << endl;
	  dump_opcode = true;
	  break;
	case 'o':
	  cout << "outfile named..." << endl;
	  outFileName = optarg;
	  break;
	case 'c':
	  cout << "combine files..." << endl;
	  combine_files = true;
	  break;
	case 'g':
	  cout << "generating digraph..." << endl;
	  gen_digraph = true;
	  break;
	default:
	  cout << "unknown " << c << endl;
	  break;
	  
	}
      
    }


  vector<string> files_to_process = parse_args( argc, argv );

  Controller * jobController = new Controller;
  Trie * tree;

    for (auto fstring = files_to_process.begin(); 
	 fstring != files_to_process.end(); ++fstring)
      {
	if (!jobController->ProcessFile( (*fstring) ) )
	  cout << "Error processing file " << (*fstring) << endl;
	else {
	  cout << "Processed file " << (*fstring) << endl;
	  tree = jobController->TreeForFile( (*fstring) );
	  cout << "Processed " << tree->NumberOfInstructions() << " instructions" << endl;
	  cout << "Processed " << tree->NumberOfUniqueInstructions() << " unique instructions" << endl;
	}

      }


    /*
     * look across our tries
     */
    size_t ninstructions = jobController->NumberOfUniqueInstructionAcrossTrees( );
    cout << "Batch: " << ninstructions << " unique instructions" << endl;
    cout << "Writing to file: " << outFileName << endl;

    if ( dump_all ) 
      {
	if ( dump_opcode ) jobController->WriteOpcodes();
	jobController->ListAllInstructionsToFile( treeName, outFileName );
      }
    else if ( dump_opcode && !gen_digraph )
      {
	jobController->WriteOpcodes();
	cout << "Dumping opcodes - mode: " << jobController->Mode() << endl;
	jobController->ListInstructionsToFile( outFileName );
      }
    else if ( gen_digraph ) 
      {
	cout << "Writing DiGraph..." << endl;
	if ( !jobController->WriteDiGraphToFile( outFileName ) )
	  cout << "Unable to write digraph to " << outFileName << endl;
	else 
	  cout << "Written..." << endl;
      }
    else
      {
	jobController->ListInstructionsToFile( outFileName );
      }
    cout << "\n";

  /*
   * Cleanup
   */

  delete jobController;

  return 0;
}

