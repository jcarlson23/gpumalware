#pragma once
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <map>

using std::string;
using std::vector;
using std::map;

template <typename T> class Matrix;
class Trie;

/*
 * Node class
 */
class Node {
 public:
  Node(const Trie * t );
  Node(const Trie * t, string& inst);
  Node(const string& inst );
  ~Node(void);

  string Instruction(void) const { return instruction; }
  unsigned long Number(void) { return inst_number; }
  void SetNextInstruction( Node * n ) { next = n; }
  void SetPrevInstruction( Node * p ) { prev = p; }
  Node *Next(void) { return next; }
  Node *Previous(void) { return prev; }
  short Opcode( void );
  string OpcodeString( void );


 private:
  string instruction;
  unsigned long inst_number;
  Node * next;
  Node * prev;
};

/*
 * Trie class...
 */
class Trie {
 public:
  Trie( ) { };
  ~Trie( );
  
  void AddInstruction( string inst );
  size_t NumberOfInstructions( void ) const  { return nodes.size(); }
  size_t NumberOfUniqueInstructions( void ) const;
  vector<Node*> InstructionBranchesFollowing( Node * ninst );
  vector<Node*> InstructionBranchesFollowing( string& inst );
  vector<string> Instructions( void );
  vector<string> Opcodes( void );
  vector<string> UniqueInstructions( void );
  vector<string> UniqueOpcodes( void );
  unsigned int FindOpcode( const string& op );
  map<string,unsigned int> OpcodeBranching( const string& op );
  Matrix<float> FullOpcodeBranching( void );
  
 private:
  vector<Node*> nodes;
  
};
