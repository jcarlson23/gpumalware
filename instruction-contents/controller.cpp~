#include <fstream>
#include <iostream>
#include "controller.h"
#include "util.h"
#include "matrix.h"

using std::fstream;
using std::pair;

Controller::Controller(void)
{
  
}

Trie *Controller::TreeForFile( const string& str )
{
  map<string,Trie*>::iterator titer = trees.find(str);
  Trie * gPtr;
  if ( titer == trees.end() ) 
    return NULL;
  
  gPtr = titer->second;
  return gPtr;
}

bool Controller::ProcessFile( const string& str )
{
  string line;
  fstream infile( str.c_str(), fstream::in );
  bool found_section = false;
  if ( !infile.good() )
    return false;
  
  vector<string> tokens;
  Trie * tree = new Trie;
  
  while ( getline( infile, line ) )
    {
      tokens = split_line( line );
      if ( tokens[0].compare( "section" ) == 0 )
	{
	  found_section = true;
	  continue;
	}
      
      if ( !found_section )
	continue;

      for ( auto tptr = tokens.begin(); tptr != tokens.end(); ++tptr )
	tree->AddInstruction( *tptr );
      
    }
  
  std::cout << "Adding tree [" << str << "]" std::endl;
  trees.insert( pair<string,Trie*>(str, tree) );

  return true;
}

size_t Controller::NumberOfUniqueInstructionAcrossTrees( void )
{
  vector<string> insts = UniqueInstructions( );
  return insts.size();
}

void Controller::WriteOpcodes(void)
{
  output_mode = Opcode;
  callback = &Controller::SetModeToNormal;
}

string Controller::Mode( void )
{
  string mode_type = "Unkown";
  if ( output_mode == Normal )
    mode_type = "Normal";
  else if ( output_mode == Opcode )
    mode_type = "Opcode";
  return mode_type;
}

vector<string> Controller::UniqueOpcodes( void )
{
  vector<string> insts;
  vector<string> sets;
  for (auto mptr = trees.begin(); mptr != trees.end(); ++mptr )
    {
      // get the unique instruction set from the trie
      sets = mptr->second->UniqueOpcodes( );

      for ( auto siter = sets.begin(); siter != sets.end(); ++siter )
	{
	  if ( (*siter).length() != 0 ) insts.push_back( (*siter) );
	}
      
    }

  // now that we've gone through all of that, let's sort the vector, and
  // erase any duplicate entries.
  std::sort( insts.begin(), insts.end(), [](const string& a, 
					    const string& b) -> bool {
	       return a.compare( b ) < 0 ? true : false;
	     });

  vector<string>::iterator liter = insts.end(), fiter = insts.end();
  for ( auto viter = insts.begin(); viter != insts.end(); ++viter )
    {
      if ( fiter != insts.end()  &&
	   fiter->compare( *viter ) == 0 ) {
	// we have a duplicate...
	liter = viter;
      }
      else {
	if ( liter != insts.end() )
	  {
	    insts.erase( fiter, liter );
	    liter = insts.end();
	  }
	fiter = viter;
      }

    }
  return insts;

}

vector<string> Controller::UniqueInstructions( void )
{
  vector<string> insts;
  vector<string> sets;
  for (auto mptr = trees.begin(); mptr != trees.end(); ++mptr )
    {
      // get the unique instruction set from the trie
      sets = mptr->second->UniqueInstructions( );

      for ( auto siter = sets.begin(); siter != sets.end(); ++siter )
	{
	  insts.push_back( (*siter) );
	}
      
    }

  // now that we've gone through all of that, let's sort the vector, and
  // erase any duplicate entries.
  std::sort( insts.begin(), insts.end(), [](const string& a, 
					    const string& b) -> bool {
	       return a.compare( b ) < 0 ? true : false;
	     });

  vector<string>::iterator liter = insts.end(), fiter = insts.end();
  for ( auto viter = insts.begin(); viter != insts.end(); ++viter )
    {
      if ( fiter != insts.end()  &&
	   fiter->compare( *viter ) == 0 ) {
	// we have a duplicate...
	liter = viter;
      }
      else {
	if ( liter != insts.end() )
	  {
	    insts.erase( fiter, liter );
	    liter = insts.end();
	  }
	fiter = viter;
      }

    }
  return insts;
}
 
bool Controller::ListAllInstructionsToFile( const string& treename, const string& filename )
{
  vector<string> insts;
  Trie * tr = trees[treename];

  if ( tr == NULL )
    return false;
  
  if ( output_mode == Normal )
    {
      insts = tr->Instructions( );
    }
  else if ( output_mode == Opcode )
    {
      insts = tr->Opcodes();
    }

  fstream outfile( filename.c_str(), fstream::out | fstream::trunc );
  for (auto iptr = insts.begin(); iptr != insts.end(); ++iptr )
    {
      outfile << *iptr << std::endl;
    }
  outfile.close();

  /*
   * If we have a callback action, do it...
   */
  if ( callback ) 
    {
      (*this.*callback)();
    }

  return true;

}

bool Controller::ListInstructionsToFile( const string& filename )
{
  vector<string> insts;
  
  if ( output_mode == Normal )
    {
      insts = UniqueInstructions( );
    }
  else if ( output_mode == Opcode )
    {
      insts = UniqueOpcodes( );
    }

  fstream outfile( filename.c_str(), fstream::out | fstream::trunc );
  for (auto iptr = insts.begin(); iptr != insts.end(); ++iptr )
    {
      outfile << *iptr << std::endl;
    }
  outfile.close();

  /*
   * If we have a callback action, do it...
   */
  if ( callback ) 
    {
      (*this.*callback)();
    }

  return true;
}

Matrix *Controller::DiGraph( void )
{
  vector<string> opcodes = UniqueOpcodes( );

  size_t nops = opcodes.size();

  Matrix* postops = new Matrix( nops );
  Trie * trie;
  unsigned int i = 0,j = 0;

  // Now loop through each instruction
  for ( auto oiter = opcodes.begin(); oiter != opcodes.end(); ++oiter )
    {
      vector<map<string,unsigned int> > branches;
      
      for ( auto piter = trees.begin(); piter != trees.end(); ++piter )
	{
	  trie = piter->second;
	  vector<string> t_ops = trie->UniqueOpcodes( );
	  map<string,unsigned int> branch = trie->OpcodeBranching( *oiter );
	  branches.push_back( branch );
	}

      // now... loop through each instruction and, look up relevant
      // maps and fill in column data...  Don't worry about Normalizing
      // the columns just now...
      j=0;
      map<string,unsigned int>::iterator bindex;
      for ( auto iiter = opcodes.begin(); iiter != opcodes.end(); ++iiter )
	{
	  // start summing...
	  unsigned int el=0;
	  for ( auto biter = branches.begin(); biter!=branches.end(); ++biter )
	    {
	      bindex = biter->find(*iiter);
	      if ( bindex != (*biter).end() )
		{
		  el += bindex->second;
		}
	    } // end of sum
	  postops->Element(i,j) = el;
	  j++;
	}
      i++; 
    }

  // Normalize by Rows..
  postops->NormalizeRows();

  return postops;
}


bool Controller::WriteDiGraphToFile( const string& filename )
{
  
  fstream fstr;
  fstr.open( filename.c_str(), fstream::out );
  Matrix * digraph;
  if ( !fstr.is_open() )
    return false;

  vector<string> codes = UniqueOpcodes( );
  digraph = DiGraph();

  for (auto citer = codes.begin(); citer != codes.end(); ++citer )
    {
      fstr << *citer;
      if ( citer+1 != codes.end() )
	fstr << ",";
    }
  fstr << std::endl;
  fstr << *digraph << std::endl;
  fstr.close();
  return true;
}
