#include "trie.h"
#include <algorithm>
#include <map>
#include "matrix.h"

using std::map;

/*
 * Node member functions...
 */
Node::Node(const Trie * t )
{
  instruction = "empty";
  inst_number = t->NumberOfInstructions( );
  
  // take care of edge cases...
  prev = NULL;
  next = NULL;
}

Node::Node(const Trie * t, string& inst )
{
  instruction = inst;
  inst_number = t->NumberOfInstructions( );
  prev = NULL;
  next = NULL;

}

Node::Node( const string& inst )
{
  instruction = inst;
  inst_number = 0;
  prev = NULL;
  next = NULL;
}

short Node::Opcode( void )
{
  long code = strtol( instruction.c_str(), NULL, 16 );
  short operation = ((code >> 20 ) & 0xff ) | ( (code >> 4) & 0x8 );
  return operation;
}

string Node::OpcodeString( void )
{
  short opcode = Opcode();
  char buffer[10];
  sprintf(buffer,"0x%02x",opcode);
  return string(buffer);
}

/*
 * Trie member functions
 */
Trie::~Trie(void)
{
  nodes.empty();
}

void Trie::AddInstruction( string inst ) 
{
  Node * node = new Node( this, inst );
  
  // if we have something to link to...
  Node * last = NULL;
  if ( nodes.size() )
    last = nodes.back();
  
  // set the next/prev pointers...
  if ( last && node )
    {
      last->SetNextInstruction( node );
      node->SetPrevInstruction( last );
    }

  if ( node )
    nodes.push_back( node );
  
}

bool fsort( const Node * a, const Node * b )
{
  if ( a && !b )
    return true;
  else if ( b && !a )
    return false;

  return a->Instruction().compare(b->Instruction() ) < 0 ? true : false;
}


size_t Trie::NumberOfUniqueInstructions(void) const
{
  /*
   * sort our our Nodes (via a copy so as to not alter our instruction
   * flow...
   */

  vector<Node*> tosort( nodes );
  string previous = "";
  size_t numinstructions = 0;

  /*
  for ( auto nptr = tosort.begin(); nptr != tosort.end(); ++nptr )
    {
      std::cout << (*nptr)->Instruction() << "\t" << *nptr << std::endl;
    }
  */


  // normal C++ sorting...
  // std::sort( tosort.begin(), tosort.end(), fsort);
  //
  // lambda function C++ sorting, casting to a bool
  std::sort( tosort.begin(), tosort.end(), [](const Node * a, 
					      const Node * b) -> bool {
	       if ( a && !b )
		 return true;
	       else if ( b && !a )
		 return false;
	       else
		 return a->Instruction().compare(b->Instruction() ) < 0 ? true : false;
	     });

  
  for ( auto nodeptr = tosort.begin(); nodeptr != tosort.end(); ++nodeptr )
    {
      // if the previous doesn't match the current...
      if ( (*nodeptr)->Instruction().compare( previous ) )
	{
	  previous = (*nodeptr)->Instruction();
	  numinstructions++;
	}
    }
  
  
  return numinstructions;
}

vector<Node*> Trie::InstructionBranchesFollowing( Node * ninst )
{
  vector<Node*> branchpts;
  for (auto nptr = nodes.begin(); nptr != nodes.end(); nptr++ )
    {
      if ( ninst->Instruction().compare( (*nptr)->Instruction() ) == 0 )
	branchpts.push_back( new Node( (*nptr)->Next()->Instruction() ) );
    }
  return branchpts;
}

unsigned int Trie::FindOpcode( const string& op )
{
  unsigned int encounters = 0;
  for (auto nptr = nodes.begin(); nptr != nodes.end(); nptr++ )
    {
      if ( (*nptr)->OpcodeString() == op )
	{
	  encounters++;
	}
    }
  return encounters;
}

vector<Node*> Trie::InstructionBranchesFollowing( string& inst )
{
  vector<Node*> branchpts;
  for (auto nptr = nodes.begin(); nptr != nodes.end(); nptr++ )
    {
      if ( inst.compare( (*nptr)->Instruction() ) == 0 )
	branchpts.push_back( new Node( (*nptr)->Next()->Instruction() ) );
    }
  return branchpts;
}

map<string,unsigned int> Trie::OpcodeBranching( const string& op )
{
  map<string,unsigned int> probs;
  map<string,unsigned int>::iterator it;
  bool flag = false;

  // first we go through and identify the opcodes occuring after "op"
  for ( auto nptr = nodes.begin(); nptr != nodes.end(); nptr++ )
    {
      string s_op = (*nptr)->OpcodeString();

      if ( flag ) {
	probs.insert( std::pair<string,unsigned int>( s_op, 0 ) );
      }

      if ( s_op == op ) {
	flag = true;
      } else {
	flag = false;
      }
      
    }

  // now we loop through and collect...
  for ( auto nptr = nodes.begin(); nptr != nodes.end(); nptr++ )
    {
      string s_op = (*nptr)->OpcodeString();

      // increment occurances..
      if ( flag ) {
	it = probs.find( s_op );
	it->second++;
      }

      if ( s_op == op ) {
	flag = true;
      } else {
	flag = false;
      }
      
    }

  return probs;
}

vector<string> Trie::Opcodes( void )
{
  vector<string> insts( nodes.size() );
  int i = 0;
  for ( auto nptr = nodes.begin(); nptr != nodes.end(); nptr++, i++ )
    {
      insts[i] = (*nptr)->OpcodeString();
    }
  return insts;
}

vector<string> Trie::Instructions( void )
{
  vector<string> insts( nodes.size() );
  int i = 0;
  for ( auto nptr = nodes.begin(); nptr != nodes.end(); nptr++, i++ )
    {
      insts[i] = (*nptr)->Instruction();
    }
  return insts;
}

vector<string> Trie::UniqueOpcodes( void )
{
  vector<string> insts;
  vector<string> all_insts = Opcodes();
  
  // now sort the insts
  std::sort( all_insts.begin(), all_insts.end(), [](const string& a, 
					      const string& b) -> bool {
		 return a.compare( b ) < 0 ? true : false;
	     });
  

  for ( auto iptr = all_insts.begin(); iptr != all_insts.end(); ++iptr )
    {
      if ( insts.size() == 0 || insts.back().compare( *iptr ) )
	insts.push_back( *iptr );
      else
	continue;
    }
  return insts;

}

vector<string> Trie::UniqueInstructions( void )
{
  vector<string> insts;
  vector<string> all_insts = Instructions();
  
  // now sort the insts
  std::sort( all_insts.begin(), all_insts.end(), [](const string& a, 
					      const string& b) -> bool {
		 return a.compare( b ) < 0 ? true : false;
	     });
  

  for ( auto iptr = all_insts.begin(); iptr != all_insts.end(); ++iptr )
    {
      if ( insts.size() == 0 || insts.back().compare( *iptr ) )
	insts.push_back( *iptr );
      else
	continue;
    }
  return insts;
}

Matrix Trie::FullOpcodeBranching( void )
{
  vector<string> codes = UniqueOpcodes();

  // create n by n matrix for what occurs after that opcode
  Matrix matrix( codes.size() );
  map<string,unsigned int>::iterator mentry;
  unsigned col = 0;

  for ( auto siter = codes.begin(); siter != codes.end(); ++siter )
    {
      // get the map...
      map<string,unsigned int> probs = OpcodeBranching( *siter );
      
      // sum the map to get probabilities...
      unsigned int intermediate_sum = 0;

      for ( auto miter = probs.begin(); miter != probs.end(); ++miter )
	{
	  intermediate_sum += miter->second;
	}

      float p;
      unsigned int row = 0;
      for ( auto coliter = codes.begin(); coliter != codes.end(); ++coliter )
	{
	  mentry = probs.find( *coliter );
	  if ( mentry == probs.end() )
	    {
	      matrix.Element(row,col) = 0;
	    }
	  else
	    {
	      matrix.Element(row,col) = (float) mentry->second / (float) intermediate_sum;
	    }

	}

    }
  // return the matrix
  return matrix;
}
